# -*- coding: utf-8 -*-
"""SmartSDLC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IRkHsjeCif_qwx1Wjp2BpZ1QHQxGBaFi
"""

!pip install transformers torch gradio PyPDF2 -q

import gradio as gr
import torch
from transformers import AutoTokenizer, AutoModelForCausalLM
import PyPDF2
import ast

# üîß Load Model and Tokenizer
model_name = "ibm-granite/granite-3.2-2b-instruct"
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForCausalLM.from_pretrained(
    model_name,
    torch_dtype=torch.float16 if torch.cuda.is_available() else torch.float32,
    device_map="auto" if torch.cuda.is_available() else None
)

if tokenizer.pad_token is None:
    tokenizer.pad_token = tokenizer.eos_token

# ‚ö° Generate AI Response with deterministic settings
def generate_response(prompt, max_length=1024):
    inputs = tokenizer(prompt, return_tensors="pt", truncation=True, max_length=512)
    if torch.cuda.is_available():
        inputs = {k: v.to(model.device) for k, v in inputs.items()}

    with torch.no_grad():
        outputs = model.generate(
            **inputs,
            max_length=max_length,
            temperature=0,
            do_sample=False,
            pad_token_id=tokenizer.eos_token_id
        )

    response = tokenizer.decode(outputs[0], skip_special_tokens=True)
    return response.replace(prompt, "").strip()

# üìÑ Extract Text Chunks from PDF
def extract_text_chunks(pdf_file, chunk_size=2000):
    try:
        pdf_reader = PyPDF2.PdfReader(pdf_file)
        full_text = ""
        for page in pdf_reader.pages:
            full_text += (page.extract_text() or "") + "\n"

        return [full_text[i:i+chunk_size] for i in range(0, len(full_text), chunk_size)]
    except Exception as e:
        return [f"‚ö†Ô∏è Error reading PDF: {str(e)}"]

# ‚úÖ Validate Python Code Syntax
def validate_python_code(code):
    try:
        ast.parse(code)
        return True, "Syntax looks valid."
    except SyntaxError as e:
        return False, f"Syntax Error: {str(e)}"

# ‚ö° Test Python Code Execution (Sandboxed)
def test_python_code_execution(code):
    try:
        exec(code, {"_builtins_": {}})
        return "Code executed without errors."
    except Exception as e:
        return f"Code execution failed: {str(e)}"

# ‚úÖ Requirement Analysis Function
def requirement_analysis(pdf_file, prompt_text):
    content = ""
    if pdf_file:
        chunks = extract_text_chunks(pdf_file)
        content = chunks[0]  # Use the first chunk for simplicity
    else:
        content = prompt_text

    analysis_prompt = (
        "üîç Analyze the following and extract key software requirements:\n\n"
        f"{content}\n\n"
        "Organize into:\n"
        "- ‚úÖ Functional Requirements\n"
        "- ‚öôÔ∏è Non-functional Requirements\n"
        "- üß± Technical Specifications"
    )
    return generate_response(analysis_prompt, max_length=1200)

# üíª Code Generation Function with Validation
def code_generation(prompt, language):
    code_prompt = (
        f"üõ†Ô∏è Generate a complete, runnable {language} code based on the following requirement. Include all necessary imports and functions:\n\n"
        f"{prompt}\n\n"
        "Code:"
    )

    code = generate_response(code_prompt, max_length=1200)

    if language.lower() == "python":
        is_valid, message = validate_python_code(code)
        if not is_valid:
            code = f"‚ö†Ô∏è Syntax error detected:\n{message}\n\n{code}"
        else:
            execution_result = test_python_code_execution(code)
            code += f"\n\n// {execution_result}"

    return code

# üåà Custom CSS for Style & Effects
custom_css = """
body, .gradio-container {
    background: linear-gradient(135deg, #000000, #0000ff) !important;
    color: white;
    min-height: 100vh;
}
.gr-block {
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 0 25px #00f;
    background-color: rgba(0, 0, 0, 0.85);
}
input, textarea, .gr-button {
    border-radius: 10px;
    box-shadow: 0 0 12px #00f;
    background-color: #111;
    color: white;
    border: 1px solid #00f;
}
.gr-button {
    background: #0000ff;
    color: white;
    font-weight: bold;
}
"""

# üöÄ Build Gradio App
with gr.Blocks(css=custom_css) as app:
    gr.Markdown("## ü§ñ Smart SDLC: AI Code Analysis & Generator")

    with gr.Tabs():
        with gr.TabItem("üìë Code Analysis"):
            with gr.Row():
                with gr.Column():
                    pdf_upload = gr.File(label="üìÇ Upload PDF (.pdf)", file_types=[".pdf"])
                    prompt_input = gr.Textbox(
                        label="üìù Or type requirements manually",
                        placeholder="Describe your software requirements...",
                        lines=5
                    )
                    analyze_btn = gr.Button("üîç Analyze Requirements")

                with gr.Column():
                    analysis_output = gr.Textbox(label="‚úÖ Analyzed Requirements", lines=20)

            analyze_btn.click(requirement_analysis, inputs=[pdf_upload, prompt_input], outputs=analysis_output)

        with gr.TabItem("üíª Code Generation"):
            with gr.Row():
                with gr.Column():
                    code_prompt = gr.Textbox(
                        label="üìù Describe Code Requirements",
                        placeholder="What code do you want to generate?",
                        lines=5
                    )
                    language_dropdown = gr.Dropdown(
                        choices=["Python", "JavaScript", "Java", "C++", "C#", "PHP", "Go", "Rust", "HTML"],
                        label="üõ†Ô∏è Programming Language",
                        value="Python"
                    )
                    generate_btn = gr.Button("‚ö° Generate Code")

                with gr.Column():
                    code_output = gr.Textbox(label="üí° Generated Code", lines=20)

            generate_btn.click(code_generation, inputs=[code_prompt, language_dropdown], outputs=code_output)

app.launch(share=True)